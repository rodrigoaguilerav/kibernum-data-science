# -*- coding: utf-8 -*-
"""Evaluación Modulo 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T6sv7g96mhdAHBx_lR3Ay5wPTH_p0SMN
"""

import string

# Definición del alfabeto base y el alfabeto rotado (ROT13)
# Se incluye la 'Ñ' en la posición 14 (índice 13)
ALFABETO_BASE = "ABCDEFGHIJKLMNÑOPQRSTUVWXYZ"
ROTACION = 13
ALFABETO_ROTADO = ALFABETO_BASE[ROTACION:] + ALFABETO_BASE[:ROTACION]

# Crear las tablas de traducción para encriptar y desencriptar
# Esto es mucho más eficiente que usar bucles o condicionales
TABLA_ENCRIPTACION = str.maketrans(
    ALFABETO_BASE, # Caracteres originales
    ALFABETO_ROTADO # Caracteres de destino (rotados)
)

TABLA_DESENCRIPTACION = str.maketrans(
    ALFABETO_ROTADO, # Caracteres originales (encriptados)
    ALFABETO_BASE    # Caracteres de destino (desencriptados)
)

def cifrar_rot13_espanol(texto: str) -> str:
    """
    Encripta una cadena de caracteres usando el algoritmo ROT13 español (con 'Ñ').

    Los caracteres que no son letras del alfabeto español (números, espacios,
    símbolos, etc.) se mantienen sin modificar.
    La función no es sensible a mayúsculas o minúsculas.

    :param texto: La cadena de caracteres a encriptar.
    :return: La cadena de caracteres encriptada.
    """
    # 1. Convertir el texto a mayúsculas para manejar mayúsculas/minúsculas de forma uniforme
    texto_mayusculas = texto.upper()

    # 2. Aplicar la tabla de traducción
    # La tabla solo afecta a los caracteres presentes en ALFABETO_BASE
    texto_encriptado = texto_mayusculas.translate(TABLA_ENCRIPTACION)

    # 3. Restaurar las mayúsculas/minúsculas del texto original
    # Recorremos el texto original y el encriptado para replicar el caso
    texto_final = ""
    for char_original, char_encriptado in zip(texto, texto_encriptado):
        if char_original.islower():
            # Si el caracter original era minúscula, el encriptado debe ser minúscula
            texto_final += char_encriptado.lower()
        else:
            # En cualquier otro caso (mayúscula, número, espacio, etc.),
            # se usa el caracter encriptado tal cual
            texto_final += char_encriptado

    return texto_final

# La función de desencriptación es idéntica a la de encriptación en un ROT cíclico,
# pero utilizamos la tabla de desencriptación para mayor claridad y modularidad.
# En ROT13, cifrar dos veces te devuelve el original.
def descifrar_rot13_espanol(texto_encriptado: str) -> str:
    """
    Desencripta una cadena de caracteres usando el algoritmo ROT13 español (con 'Ñ').

    :param texto_encriptado: La cadena de caracteres a desencriptar.
    :return: La cadena de caracteres desencriptada.
    """
    # 1. Convertir el texto a mayúsculas para manejar mayúsculas/minúsculas
    texto_mayusculas = texto_encriptado.upper()

    # 2. Aplicar la tabla de traducción de desencriptación
    texto_desencriptado = texto_mayusculas.translate(TABLA_DESENCRIPTACION)

    # 3. Restaurar las mayúsculas/minúsculas del texto original
    texto_final = ""
    for char_original_encriptado, char_desencriptado in zip(texto_encriptado, texto_desencriptado):
        if char_original_encriptado.islower():
            # Si el caracter encriptado era minúscula, el desencriptado debe ser minúscula
            texto_final += char_desencriptado.lower()
        else:
            # En cualquier otro caso, se usa el caracter desencriptado tal cual
            texto_final += char_desencriptado

    return texto_final

    ## Pruebas y Validación del Algoritmo
def ejecutar_pruebas():
    print("## Ejecutando Pruebas del Algoritmo ROT13 Español\n")

    # Definición de casos de prueba: (Entrada Original, Esperado Encriptado)
    pruebas = [
        # Caso 1: Ejemplo básico del problema
        ("HOLA", "TBXN"),
        # Caso 2: Sensibilidad a mayúsculas/minúsculas (debe mantener el caso)
        ("Hola", "Tbxn"),
        # Caso 3: Caracteres no reconocidos (símbolos y espacios)
        ("HOLA!", "TBXN!"),
        # Caso 4: Caracteres no reconocidos (números)
        ("H4L1", "T4X1"),
        # Caso 5: Frase completa con espacios y caso variado
        ("Hola como te va", "Tbxn obyb gq in"),
        # Caso 6: Prueba con la letra 'Ñ' (N debe ir a A, Ñ debe ir a O)
        ("NIÑO", "AÑBQ"),
        # Caso 7: Prueba con las letras J-K-L-M (el final del abecedario rotado)
        ("JAVIER", "WNIREN"),
        # Caso 8: Prueba con un caso extremo (mix de todo)
        ("Empresa de Programación Año 2025: Ñ", "Rñceñfn qr Ceñtenznpvóa Nä 2025: B")
    ]

    # Ejecutar encriptación
    print("### Pruebas de Encriptación")
    cifrado_exitoso = True
    for original, esperado_encriptado in pruebas:
        resultado = cifrar_rot13_espanol(original)
        estado = "CORRECTO" if resultado == esperado_encriptado else f"ERROR. Esperado: {esperado_encriptado}"
        print(f"> Original: '{original}' -> Encriptado: '{resultado}' ({estado})")
        if resultado != esperado_encriptado:
            cifrado_exitoso = False

    print("\n" + "-"*50 + "\n")

    # Ejecutar desencriptación y verificación de ciclo
    print("### Pruebas de Desencriptación (Verificación de Ciclo)")
    descifrado_exitoso = True

    # Usamos los resultados ENCRIPTADOS para probar la desencriptación
    for original, _ in pruebas:
        encriptado = cifrar_rot13_espanol(original)
        desencriptado = descifrar_rot13_espanol(encriptado)

        # El texto desencriptado DEBE ser igual al texto original
        estado = "CORRECTO" if desencriptado == original else f"ERROR. Esperado: {original}"
        print(f"> Encriptado: '{encriptado}' -> Desencriptado: '{desencriptado}' ({estado})")
        if desencriptado != original:
            descifrado_exitoso = False

    print("\n---")
    if cifrado_exitoso and descifrado_exitoso:
        print("¡Todas las pruebas de encriptación y desencriptación pasaron exitosamente!")
    else:
        print("Hubo fallos en una o más pruebas. Revisar el algoritmo.")

# Ejecutar las pruebas
if __name__ == "__main__":
    ejecutar_pruebas()